# 인덱스 INDEX
# 1. 개념

DB에서 테이블에 대한 검색 속도를 향상 시켜주는 자료구조.

- 테이블의 특정 컬럼에 인덱스를 생성하면, 해당 컬럼을 기준으로 데이터를 정렬한 후 별도의 메모리 공간에 물리적 주소와 함께 저장된다.
      - (별도의 메모리 공간 = 테이블 데이터와 다른 파일로 저장된다로 이해)
- 컬럼값과 물리적 주소를 (key, value)의 한 쌍으로 저장함.
- 보통 인덱스는 테이블 크기의 10%정도의 저장공간을 차터
- DB내에 저장된 데이터의 “주소”를 갖고 있는 것.
    
    ![INDEX_1.png](./image/INDEX_1.png)
    

# 2. 장점 = 인덱스를 사용하는 이유

- 테이블을 검색하는 속도와 성능이 향상된다. 시스템의 전반적인 부하를 줄일 수 있다.
- 인덱스에 의해 데이터들이 **정렬된 형태**를 갖기 때문에 조건에 맞는 데이터를 빠르게 찾을 수 있다.
- ORDER BY, MIN/MAX 같은 경우도 이미 정렬되어 있으므로 빠르게 수행 할 수 있다.

## 인덱스를 사용하면 좋은경우

데이터의 범위가 넓고, 중복이 적을 수록, 조회가 많거나 정렬된 상태가 유용한 칼럼에 사용

- 규모가 큰 테이블
- 삽입, 수정, 삭제 작업이 자주 발생하지 않는 칼럼
- WHERE, ORDER BY, JOIN 등이 자주 사용되는 칼럼
- 데이터의 중복도가 낮은 칼럼

# 3. 단점

- 인덱스를 관리하기 위한 추가 작업이 필요하다
- 추가 저장공간이 필요하다
- 잘못 사용하는 경우 오히려 검색 성능이 저하된다.
- 인덱스를 항상 정렬된 상태로 유지하기 때문에 인덱스가 적용된 컬럼에 삽입, 삭제, 수정 작업을 수행하면 아래의 추가 작업이 필요하다 ➡️수정이 잦은 경우 성능이 낮아짐
    - INSERT : 새로운 데이터에 대한 인덱스 추가
    - DELETE : 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업 수행
    - UPDATE : 기존의 인덱스를 사용하지 않음 처리, 갱신된 데이터에 대한 인덱스 추가
- 데이터의 인덱스를 제거하는 것이 아리)](https://github.com/psyStudy/CS_study/blob/main/DB/%EC%9D%B8%EB%8D%B1%EC%8A%A4%20%EC%A2%85%EB%A5%98.md)

## 1) 클러스터형 인덱스 Clusted Index

- 테이블당 한 개 만 생성가능
- 한 데이터를 인덱스로 지정한 열에 맞춰서 자동으로 정렬
- 기본키 설정 시 자동으로 생성되며 컬럼은 데이터 변경시, 항상 정렬을 유지함.
- 클러스터 인덱스 사용시 모든 보조 인덱스가 pk를 포함한다.
- pk의 크기가 커질수록 보조 인덱스의 크기도 커진다.
- 영어사전 느낌 인덱스 자체가 곧 내용
- 인덱스를 생성할때 데이터 페이지 전체를 다시 정렬
- 이미 대용량의 데이터가 입력된 상태라면, 업무시간에 클러스터형 인덱스를 생성하는 것은 심각한 시스템 부하를 줄 수 있으므로 신중해야함!
- 인덱스 자체의 리프페이지가 곧 데이터의 페이지 = 인덱스 자체에 데이터가 포함
- 비클러스터형 보다 검색속도가 빠르지만 / 입력, 수정, 삭제는 느림
- 비클러스터형 인덱스보다 성능이 좋지만, 테이블당 한 개만 생성할 수 있으므로 어느 열에 클러스터형 인덱스를 설정하느냐에 따라 성능이 달라질 수 있다.

## 2) 비클러스터형 인덱스 Non-Clustered Index

- 테이블당 여러 개를 생성할 수 있다. (하지만, 함부로 남용하면 오히려 시스템 성능을 떨어트릴 수 있음)
- 테이블의 페이지를 정렬하지 않고 새로운 공간을 할당하므로, 클러스터 인덱스보다 많은 공간을 차지한다.
- 데이터 행과 분리된 구조를 가진다.
- 책 뒤의 찾아보기 느낌
- 인덱스 생성시 데이터 페이지는 그대로 둔 상태에서 별도의 페이지에 인덱스 구성
- 인덱스 자체의 리프 페이지는 데이터가 아닌 데이터를 위치하는 포인터,
- 클러스터형보다 검색은 느리지만, 입력,수정,삭제 빠름

## 3) 단일 인덱스

데이터가 많지 않으며 조건에 걸리는 컬럼이 적은 경우에 주로 사용

```sql
CREATE INDEX IDX_SINGLE (C1);
```

## 4) 복합 인덱스

테이블 데이터를 기준으로 새로운 인덱스 공간을 생성 및 데이터를 정렬하므로 공간 사용량이 증가

```sql
CREATE INDEX IDX_MULTI (C1, C2);
```

여러 필드를 기반으로 조회할 때 복합 인덱스를 생성한다. → 생성 순서에 따라 성능이 달라진다.

- 같음, 정렬, 다중 값, 카디널리티 순으로 생성해야함
    1. 어떠한 값과 같음을 비교하는 ==이나 equal이라는 쿼리가 있다면 제일 먼저 인덱스로 설정한다.
    2. 정렬에 쓰는 필드라면 그 다음 인덱스로 설정한다
    3. 다중 값을 출력해야하는 필드, 즉 쿼리 자체가 >, < 등 많은 값을 출력해야하는 쿼리에 쓰는 필드라면 나중에 인덱스를 설정한다.
    4. 카디널리티가 높다 = 유니크한 값의 정도가 높다. 카디널리티가 높은 순서를 기반으로 인덱스를 생성해야한다. (age 필드와 email필드 중 당연히 email에 대한 인덱스를 먼저 생성)

## 5) 커버드 인덱스(커버드 쿼리)

쿼리가 인덱스 접근으로 인해 테이블 접근이 필요하지 않은 경우 사용

```sql
CREATE INDEX INDX_MULTI (C1, C2);
SELECT C1, C2 FROM IDX_MULTI WHERE C1 = 'value1' and C2 = 'value2';
```

## 6) Column store Index 열 저장 인덱스

- 방대한 데이터 웨어하우징 진리표를 삭제하고 질문하는 것과 관련해 표준 유형의 인덱스가 있는 SQL 서버의 인덱스 유형
- 작은 인상 안에 정보를 넣을 수 있도록 하여 속도를 높이는데 도움이 된다.
- 클라이언트가 기존의 열 정렬 용량과 달리 조회 실행이 몇 배 높은 IO를 얻을 수 있다.

## 7) Filtered Index

- 열의 값의 하위 집합에 대한 질문에 적용 가능한 숫자가 몇 개 없을 때 만들어지는 SQL Server의 인덱스 유형 중 하나.
- 테이블이 이기종 데이터 행으로 되어 있는 경우, 적어도 한 종류의 데이터에 대해 SQL에 분리된 목록이 만들어진다.

## 8) 해시 인덱스 Hash Index

- 포인터 또는 N 버킷의 배열과 각 슬롯 또는 버킷의 행을 포함하는 슬롯에 있는 SQL Server 인덱스 유형
- N : 여러버킷 / K는 임계값 → 해시함수 F(N, K) 사용
- 용량은 해시 인덱스의 버킷과 관련된 키를 나타내며 해시 인덱스의 모든 버킷은 8바이트(단위 맞는지 확인!)로 구성되며 기본 섹션의 연결된 런다운 메모리 주소를 저장하는데 사용

## 9) 고유 인덱스 Unique Index

SQL Server의 인덱스로, 인덱스 키에 본사 의존이 포함되어 있는지 확인하고 보장하며 이러한 행을 따라 클라이언트가 테이블의 각 행이 어느쪽이든 예외적인지 검사할 수 있도록함.

# cf)인덱스 생성 방법
- [페이지 분리 click!](https://github.com/psyStudy/CS_study/blob/main/DB/%EC%9D%B8%EB%8D%B1%EC%8A%A4_%EC%83%9D%EC%84%B1%EB%B0%A9%EB%B2%95.md)
- [https://land-turtler.tistory.com/120](https://land-turtler.tistory.com/120)
- [https://azderica.github.io/00-db-index/](https://azderica.github.io/00-db-index/)

---

# 면접질문

- 인덱스를 사용하는 이유가 무엇인가요?
    - where 구문에 해당하는  열을 빨리 찾기 위해서
    - join시 다른 테이블의 열을 빨리 추출하기 위해서
    - 사용가능하 키의 최 좌측 접두사(leftmst prefixf)를 가지고 정렬 및 그룹화를 하기 위해서
    - min(), max(), count값을 찾기 위해
    - 인덱스를 사용하지 않으면? 서버의 힙영역에 데이터 레코트 들이 순서 없이 저장되면, 특정 데이터를 찾기 위해 full scan(table scan)방식을 사용하게 된다. 이를 경우 용량이 큰 테이블에서 처리 성능이 떨어질 것이다.
- 인덱스의 장단접은 무엇인가요?
- 인덱스 만드는 과정을 설명해 보세요.
- 인덱스가 있음에도 인덱스를 타지 않은 경우에는 어떤 것이 있을지?

# 출처

- 인덱스 관련 질문 모음 : [https://land-turtler.tistory.com/120](https://land-turtler.tistory.com/120)
- B트리 : [https://code-lab1.tistory.com/217](https://code-lab1.tistory.com/217)
- [책] 면접을 위한 CS전공지식 노트
- [https://rebro.kr/167](https://rebro.kr/167)
- [https://mangkyu.tistory.com/96](https://mangkyu.tistory.com/96)
- OLTP : [https://unabated.tistory.com/entry/OLTP-OLAP](https://unabated.tistory.com/entry/OLTP-OLAP)
- [https://siahn95.tistory.com/77](https://siahn95.tistory.com/77)
- [https://azderica.github.io/00-db-index/](https://azderica.github.io/00-db-index/)
- [https://mongyang.tistory.com/75](https://mongyang.tistory.com/75)
